import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json


class TestbedHandler(object):

    MOTE_CMD  = ['program', 'tomoteserialbytes', 'reset', 'disable',]
    BOX_CMD   = ['changelocation', 'hostnametoscreen', 'colortoscreen', 'picturetoscreen',
                 'changesoftware', 'discovermotes', 'status', 'echo',]
    DEVICETYPE_BOX  = 'box'
    DEVICETYPE_MOTE = 'mote'

    def __init__(self,mqtt_broker , mqttclient_id, resp_dict, dataLock):

        self.dataLock               = dataLock
        self.listenSerialPorts      = False
        self.serialPortsQueues      = {}
        self.isConnected            = False
        self.resp_dict              = resp_dict
        self.mqttclient             = mqtt.Client(mqttclient_id)
        self.mqttclient.on_connect  = self._on_mqtt_connect
        self.mqttclient.on_message  = self._on_mqtt_message
        self.mqttclient.connect(mqtt_broker)
        self.mqttthread             = threading.Thread(
            name   = 'mqtt_loop_thread',
            target = self.mqttclient.loop_forever
        )
        self.mqttthread.start()

    #============================= private ========================================================

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('opentestbed/deviceType/#')
        self.isConnected    = True

    def _on_mqtt_message(self, client, userdata, message):
        not_desired_topics   = ['heartbeat', 'fromoteserialbytes', 'picturetoscreen','colortoscreen', 'hostnametoscreen']
        topic_splitted       = message.topic.split('/')
        # handle responses
        if topic_splitted[6] not in not_desired_topics and topic_splitted[5]=='resp':
            payload     = json.loads(message.payload)
            if payload['token'] not in self.resp_dict:
                self.resp_dict[payload['token']]                = {}
            self.resp_dict[payload['token']][topic_splitted[4]] = payload

        # handle notif frommoteserialbytes
        with self.dataLock:
            listen = self.listenSerialPorts

        if listen:
            if topic_splitted[6] == 'fromoteserialbytes':
                try:
                    self.serialPortsQueues[topic_splitted[4]].put(json.loads(message.payload)['serialbytes'])
                except KeyError:
                    self.serialPortsQueues[topic_splitted[4]]  = Queue.Queue()
                    self.serialPortsQueues[topic_splitted[4]].put(json.loads(message.payload)['serialbytes'])
    #============================= public =================================

    def send_command(self,deviceId, cmd, args):
        if cmd in self.MOTE_CMD:
            deviceType  = self.DEVICETYPE_MOTE
        elif cmd in self.BOX_CMD:
            deviceType  = self.DEVICETYPE_BOX
        else:
            raise Exception('not valid cmd')

        args['token']   = '{0}_{1}'.format(cmd, time.time())
        self.mqttclient.publish(
            topic       = 'opentestbed/deviceType/{0}/deviceId/{1}/cmd/{2}'.format(deviceType, deviceId, cmd),
            payload     = json.dumps(args),
        )
        return args['token']
