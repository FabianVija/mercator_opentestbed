import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json
# for mercator handler
import MercatorDefines
import struct
import Hdlc


BROKER_ADDRESS     = "argus.paris.inria.fr"
MERCATOR_2D4GHZ    = '03oos_mercator_2d4ghz.hex'
MERCATOR_SUBGHZ    = '03oos_mercator_subghz.hex'

class Experiment(object):

    def __init__(self):
        self.mercatorHandler    = MercatorHandler()
        self.dataLock           = threading.Lock()
        self.testbed_resp_dict  = {}
        self.testbed_handler    = TestbedHandler('mercator', self.testbed_resp_dict)
        while  not self.testbed_handler.is_connected:
            pass

        self.motes = self._populate_motes_list()
        print self.motes
        #self._program_mote('all', MERCATOR_2D4GHZ)
        # set all motes to idle
        self._sendDataToMote('all', self.mercatorHandler.REQ_IDLE_message())
        # make sure all motes are in idle
        self._sendDataToMote('all', self.mercatorHandler.REQ_ST_message())
        print self.motes
        print 'sended'

        # switch all motes to rx

        # check state, assert that all are in rx mode

        # switch tx mote to tx

    def _populate_motes_list(self):
        # send status cmd to all
        motes = {}
        response = self._send_command('all', 'status', {}, 0.2)
        discover_motes_threads    = []
        for b in response:
            try:
                for m in response[b]['returnVal']['motes']:
                    if m['bootload_success']:
                        motes[m['EUI64']]   = b
                    else:
                        #something to discover motes in threads
                        #TO_DO
                        pass
            except:
                pass
        return motes



    def _program_mote(self, moteId, firmware):
        payload    = {}
        with open(firmware, 'rb') as f:
            payload['hex']        = f.read()
        payload['description']    = firmware
        response   = self._send_command(moteId,'program',payload,1)
        self._removeNotRespondingMote(response)

    def _sendDataToMote(self,moteId, data):
        payload                   = {}
        payload['serialbytes']    = []
        for i in data:
            payload['serialbytes']    += [ord(i)]
        response   = self._send_command(moteId, 'tomoteserialbytes', payload, 1)
        self._removeNotRespondingMote(response)

    def _send_command(self, deviceId, cmd, args, timeout):
        goOn       = True
        response   = {}
        token      = self.testbed_handler.send_command(deviceId, cmd, args)
        while goOn:
            time.sleep(timeout)
            with self.dataLock:
                try:
                    response.update(self.testbed_resp_dict[token])
                    del self.testbed_resp_dict[token]
                except:
                    if bool(response):
                        goOn     = False
        return response

    def _removeNotRespondingMote(self, response):
        print response
        for mote in response:
            if not response[mote]['success']:
                try:
                    del self.motes[mote]
                except:
                    pass

class MercatorHandler(object):

    def __init__(self):
        self.hdlc = Hdlc.Hdlc()

    def REQ_IDLE_message(self):
        message   = struct.pack('>B', MercatorDefines.TYPE_REQ_IDLE,)
        return self.hdlc.hdlcify(message)

    def REQ_ST_message(self):
        message    = struct.pack('>B', MercatorDefines.TYPE_REQ_ST,)
        return self.hdlc.hdlcify(message)

class TestbedHandler(object):

    MOTE_CMD  = ['program', 'tomoteserialbytes', 'reset', 'disable',]
    BOX_CMD   = ['changelocation', 'hostnametoscreen', 'colortoscreen', 'picturetoscreen',
                 'changesoftware', 'discovermotes', 'status', 'echo',]
    DEVICETYPE_BOX  = 'box'
    DEVICETYPE_MOTE = 'mote'

    def __init__(self, mqttclient_id, resp_dict):

        self.is_connected           = False
        self.resp_dict              = resp_dict
        self.mqttclient             = mqtt.Client(mqttclient_id)
        self.mqttclient.on_connect  = self._on_mqtt_connect
        self.mqttclient.on_message  = self._on_mqtt_message
        self.mqttclient.connect(BROKER_ADDRESS)
        self.mqttthread             = threading.Thread(
            name   = 'mqtt_loop_thread',
            target = self.mqttclient.loop_forever
        )
        self.mqttthread.start()

    #============================= private ========================================================

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('opentestbed/deviceType/#')
        self.is_connected    = True

    def _on_mqtt_message(self, client, userdata, message):
        not_desired_topics   = ['heartbeat', 'fromoteserialbytes', 'picturetoscreen','colortoscreen', 'hostnametoscreen']
        topic_splitted       = message.topic.split('/')
        if topic_splitted[6] not in not_desired_topics and topic_splitted[5]=='resp':
            payload     = json.loads(message.payload)
            if payload['token'] not in self.resp_dict:
                self.resp_dict[payload['token']]                = {}
            self.resp_dict[payload['token']][topic_splitted[4]] = payload

    #============================= public =================================

    def send_command(self,deviceId, cmd, args):
        if cmd in self.MOTE_CMD:
            deviceType  = self.DEVICETYPE_MOTE
        elif cmd in self.BOX_CMD:
            deviceType  = self.DEVICETYPE_BOX
        else:
            raise Exception('not valid cmd')

        args['token']   = '{0}_{1}'.format(cmd, time.time())
        self.mqttclient.publish(
            topic       = 'opentestbed/deviceType/{0}/deviceId/{1}/cmd/{2}'.format(deviceType, deviceId, cmd),
            payload     = json.dumps(args),
        )
        return args['token']

if __name__ == '__main__':
    mercator_experiment = Experiment()