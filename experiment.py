import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json
import logging
import os
import sys
if __name__ == '__main__':
    here = sys.path[0]
    sys.path.insert(0, os.path.join(here, 'lib'))

import MercatorDefines
from MercatorHandler import MercatorHandler
from TestbedHandler import TestbedHandler

BROKER_ADDRESS     = "argus.paris.inria.fr"
MERCATOR_2D4GHZ    = '03oos_mercator_2d4ghz.hex'
MERCATOR_SUBGHZ    = '03oos_mercator_subghz.hex'
LOGFILE            = 'logfile.log'

class Experiment(object):

    def __init__(self):

        with open(LOGFILE, 'w') as f:
            pass
        logging.basicConfig(filename=LOGFILE, level=logging.INFO)
        self.mercatorHandler    = MercatorHandler()
        self.dataLock           = threading.RLock()
        self.testbed_resp_dict  = {}
        self.testbed_handler    = TestbedHandler(BROKER_ADDRESS, 'mercator', self.testbed_resp_dict, self.dataLock)
        while  not self.testbed_handler.isConnected:
            pass

        self.motes = self._populate_motes_list()
        print self.motes
        #self._program_mote('all', MERCATOR_2D4GHZ)
        # set all motes to idle
        self._send_data_to_mote('all', self.mercatorHandler.REQ_IDLE_message())
        # make sure all motes are in idle
        print self._check_status('all', MercatorDefines.ST_IDLE)


        print 'sended'

        # switch all motes to rx

        # check state, assert that all are in rx mode

        # switch tx mote to tx

    def _check_status(self, deviceId, status):
        # clean queues
        for q in self.testbed_handler.serialPortsQueues:
            self._clear_queue(self.testbed_handler.serialPortsQueues[q])
        self.testbed_handler.listenSerialPorts   = True

        self._send_data_to_mote(deviceId, self.mercatorHandler.REQ_ST_message())
        if deviceId == 'all':
            devices     = self.motes
        else:
            devices     = [deviceId,]

        # get the response from the motes
        for mote in devices:
            for i in range(0,10):
                if mote in self.testbed_handler.serialPortsQueues:
                    if not self.testbed_handler.serialPortsQueues[mote].empty():
                        response   = self.mercatorHandler.handle_inputbuf(
                                        self.testbed_handler.serialPortsQueues[mote].get()
                                        )
                        if response['type'] == MercatorDefines.TYPE_RESP_ST:
                            self.motes[mote]['status']     = response['status']
                        break
                time.sleep(0.1)

        motes_without_status = []
        # check status
        for mote in self.motes:
            try:
                if int(self.motes[mote]['status']) != status:
                    return False
            except KeyError:
                motes_without_status   += mote

        # delete motes without status
        for m in motes_without_status:
            del(self.motes[m])
            logging.info('{0} was removed, not status'.format(m))

        # stop listening serialports
        self.testbed_handler.listenSerialPorts   = False
        return True

    def _populate_motes_list(self):
        # send status cmd to all
        '''
         motes = { 'EUI64': {'otbox': 'otboxYY',
                             'firmware': 'xx'}
                  }
        '''
        motes = {}
        response = self._send_command('all', 'status', {}, 0.2)
        discover_motes_threads    = []
        for b in response:
            for m in response[b]['returnVal']['motes']:
                if 'bootload_success' in m:
                    if m['bootload_success']:
                        motes[m['EUI64']]   = {'otbox' :b}
                    else:
                        #something to discover motes in threads
                        #TO_DO
                        pass

        return motes

    def _program_mote(self, moteId, firmware):
        payload    = {}
        with open(firmware, 'rb') as f:
            payload['hex']        = f.read()
        payload['description']    = firmware
        response   = self._send_command(moteId,'program',payload,1)
        self._remove_not_responding_mote(response)

    def _send_data_to_mote(self,moteId, data):
        payload                   = {}
        payload['serialbytes']    = []
        for i in data:
            payload['serialbytes']    += [ord(i)]
        response   = self._send_command(moteId, 'tomoteserialbytes', payload, 1)
        self._remove_not_responding_mote(response)

    def _send_command(self, deviceId, cmd, args, timeout):
        goOn       = True
        response   = {}
        token      = self.testbed_handler.send_command(deviceId, cmd, args)
        while goOn:
            time.sleep(timeout)
            with self.dataLock:
                try:
                    response.update(self.testbed_resp_dict[token])
                    del self.testbed_resp_dict[token]
                except:
                    if bool(response):
                        goOn     = False
        return response

    def _remove_not_responding_mote(self, response):
        for mote in response:
            if not response[mote]['success']:
                try:
                    del self.motes[mote]
                    logging.info('{0} was removed, success false'.format(mote))
                except:
                    pass

    def _clear_queue(self, queue):
        while not queue.empty():
            queue.get()


if __name__ == '__main__':
    mercator_experiment = Experiment()
