import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json
import logging
# for mercator handler
import MercatorDefines
import struct
import Hdlc


BROKER_ADDRESS     = "argus.paris.inria.fr"
MERCATOR_2D4GHZ    = '03oos_mercator_2d4ghz.hex'
MERCATOR_SUBGHZ    = '03oos_mercator_subghz.hex'
LOGFILE            = 'logfile.log'

class Experiment(object):

    def __init__(self):

        with open(LOGFILE, 'w') as f:
            pass
        logging.basicConfig(filename=LOGFILE, level=logging.INFO)
        self.mercatorHandler    = MercatorHandler()
        self.dataLock           = threading.RLock()
        self.testbed_resp_dict  = {}
        self.testbed_handler    = TestbedHandler('mercator', self.testbed_resp_dict, self.dataLock)
        while  not self.testbed_handler.isConnected:
            pass
        print motes_without_status

        self.motes = self._populate_motes_list()
        print self.motes
        #self._program_mote('all', MERCATOR_2D4GHZ)
        # set all motes to idle
        self._send_data_to_mote('all', self.mercatorHandler.REQ_IDLE_message())
        # make sure all motes are in idle
        print self._check_status('all', MercatorDefines.ST_IDLE)


        print 'sended'

        # switch all motes to rx

        # check state, assert that all are in rx mode

        # switch tx mote to tx

    def _check_status(self, deviceId, status):
        # clean queues
        for q in self.testbed_handler.serialPortsQueues:
            self._clear_queue(self.testbed_handler.serialPortsQueues[q])
        self.testbed_handler.listenSerialPorts   = True

        self._send_data_to_mote(deviceId, self.mercatorHandler.REQ_ST_message())
        if deviceId == 'all':
            devices     = self.motes
        else:
            devices     = [deviceId,]

        # get the response from the motes
        for mote in devices:
            for i in range(0,10):
                if mote in self.testbed_handler.serialPortsQueues:
                    if not self.testbed_handler.serialPortsQueues[mote].empty():
                        response   = self.mercatorHandler.handle_inputbuf(
                                        self.testbed_handler.serialPortsQueues[mote].get()
                                        )
                        if response['type'] == MercatorDefines.TYPE_RESP_ST:
                            self.motes[mote]['status']     = response['status']
                        break
                time.sleep(0.1)

        motes_without_status = []
        # check status
        for mote in self.motes:
            try:
                if int(self.motes[mote]['status']) != status:
                    return False
            except KeyError:
                motes_without_status   += mote

        # delete motes without status
        for m in motes_without_status:
            del(self.motes[m])
            logging.info('{0} was removed, not status'.format(m))

        # stop listening serialports
        self.testbed_handler.listenSerialPorts   = False
        return True

    def _populate_motes_list(self):
        # send status cmd to all
        '''
         motes = { 'EUI64': {'otbox': 'otboxYY',
                             'firmware': 'xx'}
                  }
        '''
        motes = {}
        response = self._send_command('all', 'status', {}, 0.2)
        discover_motes_threads    = []
        for b in response:
            for m in response[b]['returnVal']['motes']:
                if 'bootload_success' in m:
                    if m['bootload_success']:
                        motes[m['EUI64']]   = {'otbox' :b}
                    else:
                        #something to discover motes in threads
                        #TO_DO
                        pass

        return motes

    def _program_mote(self, moteId, firmware):
        payload    = {}
        with open(firmware, 'rb') as f:
            payload['hex']        = f.read()
        payload['description']    = firmware
        response   = self._send_command(moteId,'program',payload,1)
        self._remove_not_responding_mote(response)

    def _send_data_to_mote(self,moteId, data):
        payload                   = {}
        payload['serialbytes']    = []
        for i in data:
            payload['serialbytes']    += [ord(i)]
        response   = self._send_command(moteId, 'tomoteserialbytes', payload, 1)
        self._remove_not_responding_mote(response)

    def _send_command(self, deviceId, cmd, args, timeout):
        goOn       = True
        response   = {}
        token      = self.testbed_handler.send_command(deviceId, cmd, args)
        while goOn:
            time.sleep(timeout)
            with self.dataLock:
                try:
                    response.update(self.testbed_resp_dict[token])
                    del self.testbed_resp_dict[token]
                except:
                    if bool(response):
                        goOn     = False
        return response

    def _remove_not_responding_mote(self, response):
        for mote in response:
            if not response[mote]['success']:
                try:
                    del self.motes[mote]
                    logging.info('{0} was removed, success false'.format(mote))
                except:
                    pass

    def _clear_queue(self, queue):
        while not queue.empty():
            queue.get()

class MercatorHandler(object):

    def __init__(self):
        self.hdlc = Hdlc.Hdlc()

    def REQ_IDLE_message(self):
        message   = struct.pack('>B', MercatorDefines.TYPE_REQ_IDLE,)
        return self.hdlc.hdlcify(message)

    def REQ_ST_message(self):
        message    = struct.pack('>B', MercatorDefines.TYPE_REQ_ST,)
        return self.hdlc.hdlcify(message)

    def send_REQ_RX(self, frequency, srcmac, transctr, txpksize, txfillbyte):
        [m0, m1, m2, m3, m4, m5, m6, m7] = srcmac
        message    = struct.pack(  '>BBBBBBBBBBHBB',
                                    MercatorDefines.TYPE_REQ_RX,
                                    frequency,
                                    m0, m1, m2, m3, m4, m5, m6, m7,
                                    transctr,
                                    txpksize,
                                    txfillbyte,
            )
        return self.hdlc.hdlcify(message)

    def handle_inputbuf(self, input_buf):
        for a in range(0,3):
            del(input_buf[-1])
        del(input_buf[0])
        try:
            inputtype = input_buf[0]

            if   inputtype == MercatorDefines.TYPE_IND_TXDONE:
                # parse input
                [msg_type] = \
                    struct.unpack(">B", ''.join([chr(b) for b in input_buf]))

                notif      = {
                    'type':             msg_type,
                }
                return notif

            elif inputtype == MercatorDefines.TYPE_IND_RX:

                # parse input
                [msg_type, length, rssi, flags, pkctr] = \
                    struct.unpack(">BBbBH", ''.join([chr(b) for b in input_buf]))
                if flags & (1 << 7) != 0:
                    crc = 1
                else:
                    crc = 0

                if flags & (1 << 6) != 0:
                    expected = 1
                else:
                    expected = 0

                if crc == 0 or expected == 0:
                    pkctr = 0

                notif      = {
                    'type':             msg_type,
                    'length':           length,
                    'rssi':             rssi,
                    'crc':              crc,
                    'expected':         expected,
                    'pkctr':            pkctr,
                }
                return notif

            elif inputtype == MercatorDefines.TYPE_RESP_ST:

                # parse input
                [msg_type, status, numnotifications, m1, m2, m3, m4, m5, m6, m7, m8] = \
                    struct.unpack(">BBHBBBBBBBB", ''.join([chr(b) for b in input_buf]))

                response = {
                    'type':             msg_type,
                    'status':           status,
                    'numnotifications': numnotifications,
                    'mac':              (m1, m2, m3, m4, m5, m6, m7, m8),
                }
                return response

            elif inputtype == MercatorDefines.TYPE_IND_UP:
                # parse input
                [msg_type] = \
                    struct.unpack(">B", ''.join([chr(b) for b in input_buf]))

                notif      = {
                    'type':             msg_type,
                    }
                return notif

            else:

                raise SystemError('unknown notification type {0}'.format(input_buf[0]))

        except Exception as err:
            return err

class TestbedHandler(object):

    MOTE_CMD  = ['program', 'tomoteserialbytes', 'reset', 'disable',]
    BOX_CMD   = ['changelocation', 'hostnametoscreen', 'colortoscreen', 'picturetoscreen',
                 'changesoftware', 'discovermotes', 'status', 'echo',]
    DEVICETYPE_BOX  = 'box'
    DEVICETYPE_MOTE = 'mote'

    def __init__(self, mqttclient_id, resp_dict, dataLock):

        self.dataLock               = dataLock
        self.listenSerialPorts      = False
        self.serialPortsQueues      = {}
        self.isConnected            = False
        self.resp_dict              = resp_dict
        self.mqttclient             = mqtt.Client(mqttclient_id)
        self.mqttclient.on_connect  = self._on_mqtt_connect
        self.mqttclient.on_message  = self._on_mqtt_message
        self.mqttclient.connect(BROKER_ADDRESS)
        self.mqttthread             = threading.Thread(
            name   = 'mqtt_loop_thread',
            target = self.mqttclient.loop_forever
        )
        self.mqttthread.start()

    #============================= private ========================================================

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('opentestbed/deviceType/#')
        self.isConnected    = True

    def _on_mqtt_message(self, client, userdata, message):
        not_desired_topics   = ['heartbeat', 'fromoteserialbytes', 'picturetoscreen','colortoscreen', 'hostnametoscreen']
        topic_splitted       = message.topic.split('/')
        # handle responses
        if topic_splitted[6] not in not_desired_topics and topic_splitted[5]=='resp':
            payload     = json.loads(message.payload)
            if payload['token'] not in self.resp_dict:
                self.resp_dict[payload['token']]                = {}
            self.resp_dict[payload['token']][topic_splitted[4]] = payload

        # handle notif frommoteserialbytes
        with self.dataLock:
            listen = self.listenSerialPorts

        if listen:
            if topic_splitted[6] == 'fromoteserialbytes':
                try:
                    self.serialPortsQueues[topic_splitted[4]].put(json.loads(message.payload)['serialbytes'])
                except KeyError:
                    self.serialPortsQueues[topic_splitted[4]]  = Queue.Queue()
                    self.serialPortsQueues[topic_splitted[4]].put(json.loads(message.payload)['serialbytes'])
    #============================= public =================================

    def send_command(self,deviceId, cmd, args):
        if cmd in self.MOTE_CMD:
            deviceType  = self.DEVICETYPE_MOTE
        elif cmd in self.BOX_CMD:
            deviceType  = self.DEVICETYPE_BOX
        else:
            raise Exception('not valid cmd')

        args['token']   = '{0}_{1}'.format(cmd, time.time())
        self.mqttclient.publish(
            topic       = 'opentestbed/deviceType/{0}/deviceId/{1}/cmd/{2}'.format(deviceType, deviceId, cmd),
            payload     = json.dumps(args),
        )
        return args['token']

if __name__ == '__main__':
    mercator_experiment = Experiment()
