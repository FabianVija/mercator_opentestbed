import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json

BROKER_ADDRESS     = "argus.paris.inria.fr"
MERCATOR_2D4GHZ    = 'mercator_bin/03oos_mercator_2d4ghz.hex'
MERCATOR_SUBGHZ    = 'mercator_bin/03oos_mercator_subghz.hex'

class Experiment(object):

    def __init__(self):
        self.dataLock           = threading.Lock()
        self.testbed_resp_dict  = {}
        self.testbed_handler    = TestbedHandler('mercator', self.testbed_resp_dict)
        while  not self.testbed_handler.is_connected:
            pass

        self.motes = self._populate_motes_list()
        self._program_motes(MERCATOR_2D4GHZ)

    def _populate_motes_list(self):
        # send status cmd to all
        motes = {}
        response = self._send_command('box', 'all', 'status', {}, 0.2)
        discover_motes_threads    = []
        for b in response:
            try:
                for m in response[b]['returnVal']['motes']:
                    if m['bootload_success']:
                        motes[m['EUI64']]   = b
                    else:
                        #something to discover motes in threads
                        #TO_DO
                        pass
            except:
                pass
        return motes

    def _program_motes(self, firmware):
        payload    = {}
        with open(firmware, 'rb') as f:
            payload['hex']        = f.read()
        payload['description']    = firmware
        response   = self._send_command('mote','all','program',payload,1)
        print response

    def _send_command(self, deviceType, deviceId, cmd, args, timeout):
        goOn       = True
        response   = {}
        token      = self.testbed_handler.send_command(deviceType, deviceId, cmd, args)
        while goOn:
            time.sleep(timeout)
            with self.dataLock:
                try:
                    response.update(self.testbed_resp_dict[token])
                    del self.testbed_resp_dict[token]
                except:
                    if bool(response):
                        goOn     = False
        return response

class TestbedHandler(object):

    def __init__(self, mqttclient_id, resp_dict):

        self.is_connected           = False
        self.resp_dict              = resp_dict
        self.mqttclient             = mqtt.Client(mqttclient_id)
        self.mqttclient.on_connect  = self._on_mqtt_connect
        self.mqttclient.on_message  = self._on_mqtt_message
        self.mqttclient.connect(BROKER_ADDRESS)
        self.mqttthread             = threading.Thread(
            name   = 'mqtt_loop_thread',
            target = self.mqttclient.loop_forever
        )
        self.mqttthread.start()

    #============================= private ========================================================

    def _on_mqtt_connect(self, client, userdata, flags, rc):
        client.subscribe('opentestbed/deviceType/#')
        self.is_connected    = True

    def _on_mqtt_message(self, client, userdata, message):
        not_desired_topics   = ['heartbeat', 'fromoteserialbytes', 'picturetoscreen','colortoscreen', 'hostnametoscreen']
        topic_splitted       = message.topic.split('/')
        if topic_splitted[6] not in not_desired_topics and topic_splitted[5]=='resp':
            payload     = json.loads(message.payload)
            if payload['token'] not in self.resp_dict:
                self.resp_dict[payload['token']]                = {}
            self.resp_dict[payload['token']][topic_splitted[4]] = payload

    #============================= public =================================

    def send_command(self, deviceType ,deviceId, cmd, args):
        args['token']   = '{0}_{1}'.format(cmd, time.time())
        self.mqttclient.publish(
            topic       = 'opentestbed/deviceType/{0}/deviceId/{1}/cmd/{2}'.format(deviceType, deviceId, cmd),
            payload     = json.dumps(args),
        )
        return args['token']

if __name__ == '__main__':
    mercator_experiment = Experiment()