import paho.mqtt.client as mqtt
import threading
import time
import Queue
import json
import logging
import os
import sys
if __name__ == '__main__':
    here = sys.path[0]
    sys.path.insert(0, os.path.join(here, 'lib'))

import MercatorDefines
from MercatorHandler import MercatorHandler
from TestbedHandler import TestbedHandler

BROKER_ADDRESS     = "argus.paris.inria.fr"
MERCATOR_2D4GHZ    = '03oos_mercator_2d4ghz.hex'
MERCATOR_SUBGHZ    = '03oos_mercator_subghz.hex'
LOGFILE            = 'logfile.log'
TXFILLBYTE         =  0x0a

class Experiment(object):

    def __init__(self):

        # experiment parameters
        channel                 = 12
        transaction_ctr         = 0
        tx_pkgsize              = 100

        with open(LOGFILE, 'w') as f:
            pass
        logging.basicConfig(filename=LOGFILE, level=logging.INFO)
        self.mercatorHandler    = MercatorHandler()
        self.dataLock           = threading.RLock()
        self.testbed_resp_dict  = {}
        self.testbed_handler    = TestbedHandler(BROKER_ADDRESS, 'mercator', self.testbed_resp_dict, self.dataLock)
        while  not self.testbed_handler.isConnected:
            pass

        #self.motes = self._populate_motes_list()
        self.motes = {u'00-12-4b-00-14-b5-b5-3d': {'otbox': u'otbox12'}, u'00-12-4b-00-14-b5-b5-b3': {'otbox': u'otbox12'}, u'00-12-4b-00-14-b5-b5-b5': {'otbox': u'otbox12'}, u'00-12-4b-00-14-b5-b6-1a': {'otbox': u'otbox04'}, u'00-12-4b-00-14-b5-b6-1c': {'otbox': u'otbox12'}}

        print self.motes
        #self._program_mote('all', MERCATOR_2D4GHZ)
        # set all motes to idle

        # self._send_data_to_mote('all', self.mercatorHandler.REQ_IDLE_message())
        # # make sure all motes are in idle
        # assert self._check_status('all', MercatorDefines.ST_IDLE)
        #
        # print 'status checked'
        tx_mac     = self.motes.keys()[0].split('-')
        for i in range(0,len(tx_mac)):
            tx_mac[i]   = ord(tx_mac[i].decode('hex'))

        # # switch all motes to rx
        # self._send_data_to_mote('all', self.mercatorHandler.send_REQ_RX(0, 0, channel, tx_mac, transaction_ctr, tx_pkgsize, TXFILLBYTE))
        #
        # # check state, assert that all are in rx mode
        #
        # print self._check_status('all', MercatorDefines.ST_RX)
        #
        # print 'listo'
        # switch tx mote to tx
        #self._send_data_to_mote('all', self.mercatorHandler.REQ_IDLE_message())
        self._check_status('all', MercatorDefines.ST_IDLE)
        #self._send_data_to_mote('all', self.mercatorHandler.send_REQ_RX(0, 0, channel, tx_mac, transaction_ctr, tx_pkgsize,TXFILLBYTE))

        #self._check_status('all', MercatorDefines.ST_RX)

        os._exit(1)

    def _check_status(self, deviceId, status):
        # clean queues
        for q in self.testbed_handler.serialPortsQueues:
            self._clear_queue(self.testbed_handler.serialPortsQueues[q])
        self.testbed_handler.listenSerialPorts   = True

        self._send_data_to_mote(deviceId, self.mercatorHandler.REQ_ST_message())
        if deviceId == 'all':
            devices     = self.motes
        else:
            devices     = [deviceId,]

        # get the response from the motes
        for mote in devices:
            for i in range(0,10):
                if mote in self.testbed_handler.serialPortsQueues:
                    if not self.testbed_handler.serialPortsQueues[mote].empty():
                        response   = self.mercatorHandler.handle_inputbuf(
                                        self.testbed_handler.serialPortsQueues[mote].get()
                                        )
                        if response['type'] == MercatorDefines.TYPE_RESP_ST:
                            self.motes[mote]['status']     = response['status']
                        break
                time.sleep(0.1)

        motes_without_status = []
        # check status
        for mote in self.motes:
            try:
                if int(self.motes[mote]['status']) != status:
                    return False
            except KeyError:
                motes_without_status   += [mote,]

        print 'sin status: '
        print motes_without_status
        # delete motes without status
        for m in motes_without_status:
            del(self.motes[m])
            logging.info('{0} was removed, not status'.format(m))

        # stop listening serialports
        self.testbed_handler.listenSerialPorts   = False
        return True

    def _populate_motes_list(self):
        # send status cmd to all
        '''
         motes = { 'EUI64': {'otbox': 'otboxYY',
                             'firmware': 'xx'}
                  }
        '''
        motes = {}
        response = self._send_command('all', 'status', {}, 0.2)
        discover_motes_threads    = []
        for b in response:
            for m in response[b]['returnVal']['motes']:
                if 'bootload_success' in m:
                    if m['bootload_success']:
                        motes[m['EUI64']]   = {'otbox' :b}
                    else:
                        #something to discover motes in threads
                        #TO_DO
                        pass

        return motes

    def _program_mote(self, moteId, firmware):
        payload    = {}
        with open(firmware, 'rb') as f:
            payload['hex']        = f.read()
        payload['description']    = firmware
        response   = self._send_command(moteId,'program',payload,1)
        self._remove_not_responding_mote(response)

    def _send_data_to_mote(self,moteId, data):
        payload                   = {}
        payload['serialbytes']    = []
        for i in data:
            payload['serialbytes']    += [ord(i)]
        response   = self._send_command(moteId, 'tomoteserialbytes', payload, 1)
        self._remove_not_responding_mote(response)

    def _send_command(self, deviceId, cmd, args, timeout):
        goOn       = True
        response   = {}
        token      = self.testbed_handler.send_command(deviceId, cmd, args)
        while goOn:
            time.sleep(timeout)
            with self.dataLock:
                try:
                    response.update(self.testbed_resp_dict[token])
                    del self.testbed_resp_dict[token]
                except:
                    if bool(response):
                        goOn     = False
        return response

    def _remove_not_responding_mote(self, response):
        for mote in response:
            if not response[mote]['success']:
                try:
                    del self.motes[mote]
                    logging.info('{0} was removed, success false'.format(mote))
                except:
                    pass

    def _clear_queue(self, queue):
        while not queue.empty():
            queue.get()


if __name__ == '__main__':
    mercator_experiment = Experiment()
